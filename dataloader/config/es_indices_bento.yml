# Indices settings
Indices:
  # First index
  # Name of the index to be created, existing index with same name will be deleted
  # - index_name: subjects
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     programs:
  #       type: keyword
  #     program_id:
  #       type: keyword
  #     studies:
  #       type: keyword
  #     study_acronym:
  #       type: keyword
  #     study_short_description:
  #       type: keyword
  #     lab_procedures:
  #       type: keyword
  #     subject_ids:
  #       type: keyword
  #     subject_id_num:
  #       type: integer
  #     subject_id_gs:
  #       type: search_as_you_type
  #     diagnoses:
  #       type: keyword
  #     diagnosis_gs:
  #       type: search_as_you_type
  #     rc_scores:
  #       type: keyword
  #     tumor_sizes:
  #       type: keyword
  #     chemo_regimen:
  #       type: keyword
  #     tumor_grades:
  #       type: keyword
  #     er_status:
  #       type: keyword
  #     pr_status:
  #       type: keyword
  #     endo_therapies:
  #       type: keyword
  #     meno_status:
  #       type: keyword
  #     age_at_index:
  #       type: integer
  #     age_at_index_gs:
  #       type: search_as_you_type
  #     survival_time:
  #       type: integer
  #     survival_time_unit:
  #       type: keyword
  #     tissue_type:
  #       type: keyword
  #     composition:
  #       type: keyword
  #     association:
  #       type: keyword
  #     file_type:
  #       type: keyword
  #     samples:
  #       type: keyword
  #     files:
  #       type: keyword


  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (ss:study_subject)-[:study_subject_of_study]->(s)-[:study_of_program]->(p)
  #     MATCH (ss)<-[:sf_of_study_subject]-(sf)
  #     MATCH (ss)<-[:diagnosis_of_study_subject]-(d)<-[:tp_of_diagnosis]-(tp)
  #     MATCH (ss)<-[:demographic_of_study_subject]-(demo)
  #     MATCH (ss)<-[:sample_of_study_subject]-(samp)
  #     MATCH (ss)<-[*..2]-(parent)<--(f:file)
  #     OPTIONAL MATCH (f)-[:file_of_laboratory_procedure]->(lp)
  #     RETURN DISTINCT
  #     p.program_acronym AS programs,
  #     p.program_id AS program_id,
  #     (s.study_acronym + ': ' + s.study_short_description) AS studies,
  #     s.study_acronym AS study_acronym,
  #     s.study_short_description AS study_short_description,
  #     COLLECT(DISTINCT lp.laboratory_procedure_id) AS lab_procedures,
  #     ss.study_subject_id AS subject_ids,
  #     ss.study_subject_id AS subject_id_gs,
  #     toInteger(split(ss.study_subject_id,'-')[2]) AS subject_id_num,
  #     ss.disease_subtype AS diagnoses,
  #     ss.disease_subtype AS diagnosis_gs,
  #     sf.grouped_recurrence_score AS rc_scores,
  #     d.tumor_size_group AS tumor_sizes,
  #     tp.chemotherapy_regimen AS chemo_regimen,
  #     d.tumor_grade AS tumor_grades,
  #     d.er_status AS er_status,
  #     d.pr_status AS pr_status,
  #     tp.endocrine_therapy_type AS endo_therapies,
  #     demo.menopause_status AS  meno_status,
  #     demo.age_at_index AS age_at_index,
  #     demo.age_at_index AS age_at_index_gs,
  #     demo.survival_time AS survival_time,
  #     demo.survival_time_unit AS survival_time_unit,
  #     COLLECT(DISTINCT samp.tissue_type) AS tissue_type,
  #     COLLECT(DISTINCT samp.composition) AS composition,
  #     COLLECT(DISTINCT head(labels(parent))) AS association,
  #     COLLECT(DISTINCT f.file_type) AS file_type,
  #     COLLECT(DISTINCT f.file_id) AS files,
  #     COLLECT(DISTINCT samp.sample_id) AS samples
  #     "

  # - index_name: subject_ids
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     program_id:
  #       type: keyword
  #     subject_id:
  #       type: keyword
  #     subject_ids:
  #       type: keyword
  #     subject_id_num:
  #       type: integer


  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (ss:study_subject)-[:study_subject_of_study]->(s)-[:study_of_program]->(p)
  #     RETURN DISTINCT
  #     p.program_id AS program_id,
  #     ss.study_subject_id AS subject_id,
  #     toLower(ss.study_subject_id) AS subject_ids,
  #     toInteger(split(ss.study_subject_id,'-')[2]) AS subject_id_num
  #     "

  # - index_name: samples
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     programs:
  #       type: keyword
  #     program_id:
  #       type: keyword
  #     study_acronym:
  #       type: keyword
  #     studies:
  #       type: keyword
  #     subject_ids:
  #       type: keyword
  #     subject_id_num:
  #       type: keyword
  #     sample_ids:
  #       type: keyword
  #     sample_id_gs:
  #       type: search_as_you_type
  #     sample_id_num:
  #       type: integer
  #     diagnoses:
  #       type: keyword
  #     rc_scores:
  #       type: keyword
  #     tumor_sizes:
  #       type: keyword
  #     chemo_regimen:
  #       type: keyword
  #     tumor_grades:
  #       type: keyword
  #     er_status:
  #       type: keyword
  #     pr_status:
  #       type: keyword
  #     endo_therapies:
  #       type: keyword
  #     meno_status:
  #       type: keyword
  #     tissue_type:
  #       type: keyword
  #     tissue_type_gs:
  #       type: search_as_you_type
  #     composition:
  #       type: keyword
  #     sample_anatomic_site:
  #       type: keyword
  #     sample_anatomic_site_gs:
  #       type: search_as_you_type
  #     sample_procurement_method:
  #       type: keyword
  #     files:
  #       type: keyword
  #     platform:
  #       type: keyword
  #     association:
  #       type: keyword
  #     file_type:
  #       type: keyword
  #     age_at_index:
  #       type: integer


  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (ss:study_subject)-[:study_subject_of_study]->(s)-[:study_of_program]->(p)
  #     MATCH (ss)<-[:sf_of_study_subject]-(sf)
  #     MATCH (ss)<-[:diagnosis_of_study_subject]-(d)<-[:tp_of_diagnosis]-(tp)
  #     MATCH (ss)<-[:demographic_of_study_subject]-(demo)
  #     MATCH (ss)<-[:sample_of_study_subject]-(samp)
  #     MATCH (samp)<-[*]-(f:file)
  #     MATCH (parent)<--(f)
  #     OPTIONAL MATCH (f)-[:file_of_laboratory_procedure]->(lp)
  #     RETURN DISTINCT
  #     p.program_acronym AS programs,
  #     p.program_id AS program_id,
  #     (s.study_acronym + ': ' + s.study_short_description) AS studies,
  #     s.study_acronym AS study_acronym,
  #     samp.sample_id AS sample_ids,
  #     samp.sample_id AS sample_id_gs,
  #     samp.sample_anatomic_site AS sample_anatomic_site,
  #     samp.sample_anatomic_site AS sample_anatomic_site_gs,
  #     samp.method_of_sample_procurement AS sample_procurement_method,
  #     lp.test_name AS platform,
  #     toInteger(split(samp.sample_id,'-')[2]) AS sample_id_num,
  #     ss.study_subject_id AS subject_ids,
  #     toInteger(split(ss.study_subject_id,'-')[2]) AS subject_id_num,
  #     ss.disease_subtype AS diagnoses,
  #     sf.grouped_recurrence_score AS rc_scores,
  #     d.tumor_size_group AS tumor_sizes,
  #     tp.chemotherapy_regimen AS chemo_regimen,
  #     d.tumor_grade AS tumor_grades,
  #     d.er_status AS er_status,
  #     d.pr_status AS pr_status,
  #     tp.endocrine_therapy_type AS endo_therapies,
  #     demo.menopause_status AS  meno_status,
  #     demo.age_at_index AS age_at_index,
  #     samp.tissue_type AS tissue_type,
  #     samp.tissue_type AS tissue_type_gs,
  #     samp.composition AS composition,
  #     COLLECT(DISTINCT f.file_id) AS files,
  #     COLLECT(DISTINCT head(labels(parent))) AS association,
  #     COLLECT(DISTINCT f.file_type) AS file_type
  #     "
  # - index_name: files
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     programs:
  #       type: keyword
  #     program_id:
  #       type: keyword
  #     studies:
  #       type: keyword
  #     study_acronym:
  #       type: keyword
  #     subject_ids:
  #       type: keyword
  #     subject_id_num:
  #       type: integer
  #     sample_ids:
  #       type: keyword
  #     sample_id_num:
  #       type: integer
  #     file_ids:
  #       type: keyword
  #     file_id_num:
  #       type: integer
  #     file_id_gs:
  #       type: search_as_you_type
  #     file_names:
  #       type: keyword
  #     file_name_gs:
  #       type: search_as_you_type
  #     file_description:
  #       type: keyword
  #     file_format:
  #       type: keyword
  #     file_format_gs:
  #       type: search_as_you_type
  #     file_size:
  #       type: double
  #     md5sum:
  #       type: keyword
  #     diagnoses:
  #       type: keyword
  #     rc_scores:
  #       type: keyword
  #     tumor_sizes:
  #       type: keyword
  #     chemo_regimen:
  #       type: keyword
  #     tumor_grades:
  #       type: keyword
  #     er_status:
  #       type: keyword
  #     pr_status:
  #       type: keyword
  #     endo_therapies:
  #       type: keyword
  #     meno_status:
  #       type: keyword
  #     tissue_type:
  #       type: keyword
  #     composition:
  #       type: keyword
  #     association:
  #       type: keyword
  #     file_type:
  #       type: keyword
  #     age_at_index:
  #       type: integer

  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (ss:study_subject)<-[*..2]-(parent)<--(f:file)
  #     MATCH (ss)<-[:sf_of_study_subject]-(sf)
  #     MATCH (ss)<-[:diagnosis_of_study_subject]-(d)<-[:tp_of_diagnosis]-(tp)
  #     MATCH (ss)-[:study_subject_of_study]->(s)-[:study_of_program]->(p)
  #     MATCH (ss)<-[:demographic_of_study_subject]-(demo)
  #     MATCH (f)-[*]->(samp:sample)
  #     RETURN DISTINCT
  #     p.program_acronym AS programs,
  #     p.program_id AS program_id,
  #     (s.study_acronym + ': ' + s.study_short_description) AS studies,
  #     s.study_acronym AS study_acronym,
  #     ss.study_subject_id AS subject_ids,
  #     toInteger(split(ss.study_subject_id,'-')[2]) AS subject_id_num,
  #     f.file_id AS file_ids,
  #     f.file_id AS file_id_gs,
  #     f.file_name AS file_names,
  #     f.file_name AS file_name_gs,
  #     f.file_description AS file_description,
  #     f.file_format AS file_format,
  #     f.file_format AS file_format_gs,
  #     f.file_size AS file_size,
  #     f.md5sum AS md5sum,
  #     toInteger(split(f.file_id,'-')[2]) AS file_id_num,
  #     ss.disease_subtype AS diagnoses,
  #     sf.grouped_recurrence_score AS rc_scores,
  #     d.tumor_size_group AS tumor_sizes,
  #     tp.chemotherapy_regimen AS chemo_regimen,
  #     d.tumor_grade AS tumor_grades,
  #     d.er_status AS er_status,
  #     d.pr_status AS pr_status,
  #     tp.endocrine_therapy_type AS endo_therapies,
  #     demo.menopause_status AS  meno_status,
  #     demo.age_at_index AS age_at_index,
  #     samp.sample_id AS sample_ids,
  #     toInteger(split(samp.sample_id,'-')[2]) AS sample_id_num,
  #     samp.tissue_type AS tissue_type,
  #     samp.composition AS composition,
  #     head(labels(parent)) AS association,
  #     f.file_type AS file_type
  #     order by f.file_id
  #     "

  # - index_name: programs
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     program_code:
  #       type: search_as_you_type
  #     program_id:
  #       type: search_as_you_type
  #     program_id_kw:
  #       type: keyword
  #     program_file_names:
  #       type: search_as_you_type
  #     program_name:
  #       type: search_as_you_type

  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (p:program)
  #     OPTIONAL MATCH (p)<--(pf:file)
  #     RETURN DISTINCT
  #       p.program_acronym AS program_code,
  #       p.program_id AS program_id,
  #       p.program_id AS program_id_kw,
  #       p.program_name AS program_name,
  #       COLLECT(DISTINCT pf.file_name) AS program_file_names
  #     "
  # - index_name: studies
  #   type: neo4j
  #   # type mapping for each property of the index
  #   mapping:
  #     program_id:
  #       type: search_as_you_type
  #     study_code:
  #       type: search_as_you_type
  #     study_id:
  #       type: search_as_you_type
  #     study_id_kw:
  #       type: keyword
  #     study_name:
  #       type: search_as_you_type
  #     study_type:
  #       type: search_as_you_type
  #     study_file_names:
  #       type: search_as_you_type

  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #     MATCH (s:study)
  #     OPTIONAL MATCH (s)<--(sf:file)
  #     OPTIONAL MATCH (s)-->(p:program)
  #     RETURN DISTINCT
  #       p.program_id AS program_id,
  #       s.study_id AS study_id,
  #       s.study_id AS study_id_kw,
  #       s.study_acronym AS study_code,
  #       s.study_name AS study_name,
  #       s.study_type AS study_type,
  #       COLLECT(DISTINCT sf.file_name) AS study_file_names
  #     "

  # - index_name: about_page
  #   type: about_file
  #   # type mapping for each property of the index
  #   mapping:
  #     page:
  #       type: search_as_you_type
  #     title:
  #       type: search_as_you_type
  #     primaryContentImage:
  #       type: text
  #     content:
  #       type: object

  # - index_name: model_nodes
  #   type: model
  #   subtype: node
  #   # type mapping for each property of the index
  #   mapping:
  #     node:
  #       type: search_as_you_type
  #     node_kw:
  #       type: keyword

  # - index_name: model_properties
  #   type: model
  #   subtype: property
  #   # type mapping for each property of the index
  #   mapping:
  #     node:
  #       type: search_as_you_type
  #     property:
  #       type: search_as_you_type
  #     property_kw:
  #       type: keyword
  #     property_description:
  #       type: search_as_you_type
  #     property_required:
  #       type: search_as_you_type
  #     property_type:
  #       type: search_as_you_type

  # - index_name: model_values
  #   type: model
  #   subtype: value
  #   # type mapping for each property of the index
  #   mapping:
  #     node:
  #       type: search_as_you_type
  #     property:
  #       type: search_as_you_type
  #     property_description:
  #       type: search_as_you_type
  #     property_required:
  #       type: search_as_you_type
  #     property_type:
  #       type: search_as_you_type
  #     value:
  #       type: search_as_you_type
  #     value_kw:
  #       type: keyword

  # - index_name: filter_ids
  #   type: neo4j
  #   mapping:
  #     project_ids:
  #       type: keyword
  #     publication_ids:
  #       type: keyword
  #     accessions:
  #       type: keyword
  #     clinical_trial_ids:
  #       type: keyword
  #     patent_ids:
  #       type: keyword
  #     programs:
  #       type: keyword
  #     docs:
  #       type: keyword
  #     fiscal_years:
  #       type: keyword
  #     award_amounts:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)
  #       OPTIONAL MATCH (pr)<--(pub:publication)
  #       OPTIONAL MATCH (pr)<--(:publication)<--(dt)
  #           WHERE dt:geo OR dt:sra OR dt:dbgap
  #       OPTIONAL MATCH (ct:clinical_trial)
  #           WHERE EXISTS((ct)-->(:publication)-->(pr)) OR EXISTS((pr)<--(ct))
  #       OPTIONAL MATCH (pr)<--(pat)
  #           WHERE pat:granted_patent OR pat:patent_application
  #       RETURN DISTINCT
  #           COLLECT(DISTINCT pr.project_id) AS project_ids,
  #           COLLECT(DISTINCT pub.publication_id) AS publication_ids,
  #           COLLECT(DISTINCT dt.accession) AS accessions,
  #           COLLECT(DISTINCT ct.clinical_trial_id) AS clinical_trial_ids,
  #           COLLECT(DISTINCT pat.patent_id) AS patent_ids,
  #           p.program_id AS programs,
  #           pr.lead_doc AS docs,
  #           pr.fiscal_year AS fiscal_years,
  #           pr.award_amount_category AS award_amounts
  #     "

  - index_name: programs
    type: neo4j
    mapping:
      program_id:
        type: keyword
      lead_doc:
        type: keyword
      fiscal_year:
        type: keyword
      award_amount:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (p:program)<--(pr:project)
        RETURN DISTINCT
          p.program_id AS program_id,
          pr.lead_doc AS lead_doc,
          pr.fiscal_year AS fiscal_year,
          pr.award_amount_category AS award_amount
      "

  - index_name: patents
    type: neo4j
    mapping:
      program_id:
        type: keyword
      lead_doc:
        type: keyword
      fiscal_year:
        type: keyword
      award_amount:
        type: keyword
      patent_id:
        type: keyword
      fulfilled_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      queried_project_ids:
        type: text
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (p:program)<--(pr:project)<--(pat)
          WHERE (pat:granted_patent OR pat:patent_application)
        RETURN DISTINCT
            COLLECT(DISTINCT p.program_id) AS program_id,
            COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
            COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
            COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
            pat.patent_id AS patent_id,
            pat.fulfilled_date AS fulfilled_date,
            COLLECT(DISTINCT pr.queried_project_id) AS queried_project_ids
       "

  - index_name: clinical_trials
    type: neo4j
    mapping:
      program_id:
        type: keyword
      lead_doc:
        type: keyword
      fiscal_year:
        type: keyword
      award_amount:
        type: keyword
      clinical_trial_id:
        type: keyword
      title:
        type: text
      last_update_posted:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      recruitment_status:
        type: text
      queried_project_ids:
        type: text
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (ct:clinical_trial)
        OPTIONAL MATCH (p:program)<--(pr:project)
            WHERE (pr)<--(:publication)<--(ct) OR (pr)<--(ct)
        RETURN DISTINCT
          COLLECT(DISTINCT p.program_id) AS program_id,
          COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
          COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
          COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
          ct.clinical_trial_id AS clinical_trial_id,
          ct.title AS title,
          ct.last_update_posted AS last_update_posted,
          ct.recruitment_status AS recruitment_status,
          COLLECT(DISTINCT pr.queried_project_id) AS queried_project_ids
      "

  # - index_name: datasets
  #   type: neo4j
  #   mapping:
  #     program_id:
  #       type: keyword
  #     lead_doc:
  #       type: keyword
  #     fiscal_year:
  #       type: keyword
  #     award_amount:
  #       type: keyword
  #     accession:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)<--(:publication)<--(dt)
  #         WHERE dt:geo OR dt:sra OR dt:dbgap
  #       RETURN DISTINCT
  #         COLLECT(DISTINCT p.program_id) AS program_id,
  #         COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
  #         COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
  #         COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
  #         dt.accession AS accession
  #     "

  # - index_name: clinical_trials
  #   type: neo4j
  #   mapping:
  #     program_id:
  #       type: keyword
  #     lead_doc:
  #       type: keyword
  #     fiscal_year:
  #       type: keyword
  #     award_amount:
  #       type: keyword
  #     clinical_trial_id:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)
  #       OPTIONAL MATCH (ct:clinical_trial)
  #         WHERE EXISTS((ct)-->(:publication)-->(pr)) OR EXISTS((pr)<--(ct))
  #       RETURN DISTINCT
  #         COLLECT(DISTINCT p.program_id) AS program_id,
  #         COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
  #         COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
  #         COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
  #         ct.clinical_trial_id AS clinical_trial_id
  #     "

  # - index_name: patents
  #   type: neo4j
  #   mapping:
  #     program_id:
  #       type: keyword
  #     lead_doc:
  #       type: keyword
  #     fiscal_year:
  #       type: keyword
  #     award_amount:
  #       type: keyword
  #     patent_id:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)<--(pat)
  #         WHERE pat:granted_patent OR pat:patent_application
  #       RETURN DISTINCT
  #         COLLECT(DISTINCT p.program_id) AS program_id,
  #         COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
  #         COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
  #         COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
  #         pat.patent_id AS patent_id
  #     "

  # - index_name: datasets
  #   type: neo4j
  #   mapping:
  #     program_id:
  #       type: keyword
  #     lead_doc:
  #       type: keyword
  #     fiscal_year:
  #       type: keyword
  #     award_amount:
  #       type: keyword
  #     accession:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)<--(:publication)<--(dt)
  #         WHERE dt:geo OR dt:sra OR dt:dbgap
  #       RETURN DISTINCT
  #         COLLECT(DISTINCT p.program_id) AS program_id,
  #         COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
  #         COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
  #         COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
  #         dt.accession AS accession
  #     "

  - index_name: datasets
    type: neo4j
    mapping:
      program_id:
        type: keyword
      lead_doc:
        type: keyword
      fiscal_year:
        type: keyword
      award_amount:
        type: keyword
      accession:
        type: keyword
      type:
        type: keyword
      accession:
        type: keyword
      title:
        type: text
      release_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      registration_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      bioproject_accession:
        type: keyword
      status:
        type: keyword
      submission_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      last_update_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      queried_project_ids:
        type: text
      link:
        type: keyword
      transformed_type:
        type: keyword
      link:
        type: keyword
  # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (p:program)<--(pr:project)<--(:publication)<--(dt)
          WHERE (dt:geo OR dt:sra OR dt:dbgap)
        RETURN DISTINCT
          COLLECT(DISTINCT p.program_id) AS program_id,
          COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
          COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
          COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
          COLLECT(DISTINCT pr.queried_project_id) AS queried_project_ids,
          LABELS(dt)[0] AS type,
          dt.accession AS accession,
          dt.title AS title,
          dt.release_date AS release_date,
          dt.registration_date AS registration_date,
          dt.bioproject_accession AS bioproject_accession,
          dt.status AS status,
          dt.submission_date AS submission_date,
          dt.last_update_date AS last_update_date,
          CASE LABELS(dt)[0]
            WHEN 'geo' THEN 'GEO'
            WHEN 'sra' THEN 'SRA'
            WHEN 'dbgap' THEN 'dbGaP' END AS transformed_type,
          CASE LABELS(dt)[0]
            WHEN 'geo' THEN 'https://www.ncbi.nlm.nih.gov/gds/?term=' + dt.accession
            WHEN 'sra' THEN 'https://www.ncbi.nlm.nih.gov/gds/?term=' + dt.accession
            WHEN 'dbgap' THEN 'https://www.ncbi.nlm.nih.gov/gds/?term=' + dt.accession END AS link
      "

  - index_name: publications
    type: neo4j
    mapping:
      program_id:
        type: keyword
      lead_doc:
        type: keyword
      fiscal_year:
        type: keyword
      award_amount:
        type: keyword
      queried_project_ids:
        type: text
      publication_id:
        type: keyword
      pmc_id:
        type: text
      year:
        type: date
        format: YYYY
      journal:
        type: text
      title:
        type: text
      authors:
        type: text
      publish_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      citation_count:
        type: integer
      relative_citation_ratio:
        type: float
      nih_percentile:
        type: float
      doi:
        type: text
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (p:program)<--(pr:project)<--(pub:publication)
        RETURN DISTINCT
          COLLECT(DISTINCT p.program_id) AS program_id,
          COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
          COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
          COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
          COLLECT(DISTINCT pr.queried_project_id) AS queried_project_ids,
          pub.publication_id AS publication_id,
          pub.pmc_id AS pmc_id,
          pub.year AS year,
          pub.journal AS journal,
          pub.title AS title,
          pub.authors AS authors,
          pub.publish_date AS publish_date,
          pub.citation_count AS citation_count,
          pub.relative_citation_ratio AS relative_citation_ratio,
          pub.nih_percentile AS nih_percentile,
          pub.doi AS doi
       "

  # - index_name: publications
  #   type: neo4j
  #   mapping:
  #     program_id:
  #       type: keyword
  #     lead_doc:
  #       type: keyword
  #     fiscal_year:
  #       type: keyword
  #     award_amount:
  #       type: keyword
  #     publication_id:
  #       type: keyword
  #   # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
  #   cypher_query: "
  #       MATCH (p:program)<--(pr:project)<--(pub:publication)
  #       RETURN DISTINCT
  #         COLLECT(DISTINCT p.program_id) AS program_id,
  #         COLLECT(DISTINCT pr.lead_doc) AS lead_doc,
  #         COLLECT(DISTINCT pr.fiscal_year) AS fiscal_year,
  #         COLLECT(DISTINCT pr.award_amount_category) AS award_amount,
  #         pub.publication_id AS publication_id
  #       "

  - index_name: projects
    type: neo4j
    mapping:
      program:
        type: keyword
      project_id:
        type: keyword
      application_id:
        type: text
      fiscal_year:
        type: keyword
      project_title:
        type: text
      project_type:
        type: text
      abstract_text:
        type: text
      keywords:
        type: text
      org_name:
        type: text
      org_city:
        type: text
      org_state:
        type: text
      org_country:
        type: text
      principal_investigators:
        type: text
      lead_doc:
        type: keyword
      program_officers:
        type: text
      award_amount:
        type: keyword
      nci_funded_amount:
        type: integer
      award_notice_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      project_start_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      project_end_date:
        type: date
        format: DD-MMM-YYYY||D-MMM-YYYY
      full_foa:
        type: text
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
        MATCH (pr:project)
        OPTIONAL MATCH (p:program)<--(pr)
        RETURN DISTINCT
          p.program_id AS program,
          pr.project_id AS project_id,
          pr.application_id AS application_id,
          pr.fiscal_year AS fiscal_year,
          pr.project_title AS project_title,
          pr.project_type AS project_type,
          pr.abstract_text AS abstract_text,
          pr.keywords AS keywords,
          pr.org_name AS org_name,
          pr.org_city AS org_city,
          pr.org_state AS org_state,
          pr.org_country AS org_country,
          pr.principal_investigators AS principal_investigators,
          pr.lead_doc AS lead_doc,
          pr.program_officers AS program_officers,
          pr.award_amount AS award_amount,
          pr.nci_funded_amount AS nci_funded_amount,
          pr.award_notice_date AS award_notice_date,
          pr.project_start_date AS project_start_date,
          pr.project_end_date AS project_end_date,
          pr.full_foa As full_foa
      "
